--- dwl/Makefile	2026-01-26 11:54:21.094332747 +0700
+++ dwl/Makefile.new	2026-01-26 12:16:43.524272896 +0700
@@ -22,7 +22,7 @@
 dwl.o: dwl.c client.h config.h config.mk cursor-shape-v1-protocol.h \
 	pointer-constraints-unstable-v1-protocol.h wlr-layer-shell-unstable-v1-protocol.h \
 	wlr-output-power-management-unstable-v1-protocol.h xdg-shell-protocol.h \
-	dwl-ipc-unstable-v2-protocol.h
+	dwl-ipc-unstable-v2-protocol.h wlr-foreign-toplevel-management-unstable-v1-protocol.h
 util.o: util.c util.h
 dwl-ipc-unstable-v2-protocol.o: dwl-ipc-unstable-v2-protocol.c dwl-ipc-unstable-v2-protocol.h
 
@@ -53,6 +53,9 @@
 dwl-ipc-unstable-v2-protocol.c:
 	$(WAYLAND_SCANNER) private-code \
 		protocols/dwl-ipc-unstable-v2.xml $@
+wlr-foreign-toplevel-management-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/wlr-foreign-toplevel-management-unstable-v1.xml $@
 
 config.h:
 	cp config.def.h $@

--- dwl/dwl.c	2026-01-26 11:54:41.033595674 +0700
+++ dwl/dwl.c.new	2026-01-26 12:27:12.814244839 +0700
@@ -24,6 +24,7 @@
 #include <wlr/types/wlr_data_device.h>
 #include <wlr/types/wlr_drm.h>
 #include <wlr/types/wlr_export_dmabuf_v1.h>
+#include <wlr/types/wlr_foreign_toplevel_management_v1.h>
 #include <wlr/types/wlr_fractional_scale_v1.h>
 #include <wlr/types/wlr_gamma_control_v1.h>
 #include <wlr/types/wlr_idle_inhibit_v1.h>
@@ -129,6 +130,11 @@
 	struct wl_listener fullscreen;
 	struct wl_listener set_decoration_mode;
 	struct wl_listener destroy_decoration;
+	struct wlr_foreign_toplevel_handle_v1 *foreign_toplevel;
+	struct wl_listener factivate;
+	struct wl_listener fclose;
+	struct wl_listener ffullscreen;
+	struct wl_listener fdestroy;
 #ifdef XWAYLAND
 	struct wl_listener activate;
 	struct wl_listener associate;
@@ -385,8 +391,14 @@
 static void xytonode(double x, double y, struct wlr_surface **psurface,
 		Client **pc, LayerSurface **pl, double *nx, double *ny);
 static void zoom(const Arg *arg);
+static void createforeigntoplevel(Client *c);
+static void factivatenotify(struct wl_listener *listener, void *data);
+static void fclosenotify(struct wl_listener *listener, void *data);
+static void fdestroynotify(struct wl_listener *listener, void *data);
+static void ffullscreennotify(struct wl_listener *listener, void *data);
 
 /* variables */
+static const char broken[] = "broken";
 static pid_t child_pid = -1;
 static int locked;
 static void *exclusive_focus;
@@ -475,6 +487,8 @@
 static struct zdwl_ipc_manager_v2_interface dwl_manager_implementation = {.release = dwl_ipc_manager_release, .get_output = dwl_ipc_manager_get_output};
 static struct zdwl_ipc_output_v2_interface dwl_output_implementation = {.release = dwl_ipc_output_release, .set_tags = dwl_ipc_output_set_tags, .set_layout = dwl_ipc_output_set_layout, .set_client_tags = dwl_ipc_output_set_client_tags};
 
+static struct wlr_foreign_toplevel_manager_v1 *foreign_toplevel_mgr;
+
 #ifdef XWAYLAND
 static void activatex11(struct wl_listener *listener, void *data);
 static void associatex11(struct wl_listener *listener, void *data);
@@ -525,6 +539,12 @@
 	appid = client_get_appid(c);
 	title = client_get_title(c);
 
+	if (c->foreign_toplevel) {
+		wlr_foreign_toplevel_handle_v1_set_app_id(c->foreign_toplevel, appid);
+		wlr_foreign_toplevel_handle_v1_set_title(c->foreign_toplevel, title);
+	}
+
+
 	for (r = rules; r < END(rules); r++) {
 		if ((!r->title || strstr(title, r->title))
 				&& (!r->id || strstr(appid, r->id))) {
@@ -1695,6 +1715,8 @@
 			client_set_border_color(old_c, bordercolor);
 
 			client_activate_surface(old, 0);
+			if (old_c->foreign_toplevel)
+				wlr_foreign_toplevel_handle_v1_set_activated(old_c->foreign_toplevel, 0);
 		}
 	}
 	printstatus();
@@ -1713,6 +1735,8 @@
 
 	/* Activate the new client */
 	client_activate_surface(client_surface(c), 1);
+	if (c->foreign_toplevel)
+		wlr_foreign_toplevel_handle_v1_set_activated(c->foreign_toplevel, 1);
 }
 
 void
@@ -2092,6 +2116,8 @@
 		c->border[i]->node.data = c;
 	}
 
+	createforeigntoplevel(c);
+
 	/* Initialize client geometry with room for border */
 	client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 	c->geom.width += 2 * c->bw;
@@ -2711,12 +2737,17 @@
 	c->prev = c->geom;
 
 	/* Scene graph sends surface leave/enter events on move and resize */
-	if (oldmon)
+	if (oldmon) {
+		if (c->foreign_toplevel)
+			wlr_foreign_toplevel_handle_v1_output_leave(c->foreign_toplevel, oldmon->wlr_output);
 		arrange(oldmon);
+	}
 	if (m) {
 		/* Make sure window actually overlaps with the monitor */
 		resize(c, c->geom, 0);
 		c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
+		if (c->foreign_toplevel)
+			wlr_foreign_toplevel_handle_v1_output_enter(c->foreign_toplevel, m->wlr_output);
 		setfullscreen(c, c->isfullscreen); /* This will call arrange(c->mon) */
 		setfloating(c, c->isfloating);
 	}
@@ -2834,6 +2865,9 @@
 
 	wlr_scene_set_gamma_control_manager_v1(scene, wlr_gamma_control_manager_v1_create(dpy));
 
+	/* Initializes foreign toplevel management */
+	foreign_toplevel_mgr = wlr_foreign_toplevel_manager_v1_create(dpy);
+
 	power_mgr = wlr_output_power_manager_v1_create(dpy);
 	wl_signal_add(&power_mgr->events.set_mode, &output_power_mgr_set_mode);
 
@@ -3159,6 +3193,11 @@
 		wl_list_remove(&c->flink);
 	}
 
+	if (c->foreign_toplevel) {
+		wlr_foreign_toplevel_handle_v1_destroy(c->foreign_toplevel);
+		c->foreign_toplevel = NULL;
+	}
+
 	wlr_scene_node_destroy(&c->scene->node);
 	printstatus();
 	motionnotify(0, NULL, 0, 0, 0, 0);
@@ -3274,6 +3313,12 @@
 updatetitle(struct wl_listener *listener, void *data)
 {
 	Client *c = wl_container_of(listener, c, set_title);
+	if (c->foreign_toplevel) {
+		const char *title;
+		if (!(title = client_get_title(c)))
+			title = broken;
+		wlr_foreign_toplevel_handle_v1_set_title(c->foreign_toplevel, title);
+	}
 	if (c == focustop(c->mon))
 		printstatus();
 }
@@ -3403,6 +3448,54 @@
 	arrange(selmon);
 }
 
+void
+createforeigntoplevel(Client *c)
+{
+	c->foreign_toplevel = wlr_foreign_toplevel_handle_v1_create(foreign_toplevel_mgr);
+
+	LISTEN(&c->foreign_toplevel->events.request_activate, &c->factivate, factivatenotify);
+	LISTEN(&c->foreign_toplevel->events.request_close, &c->fclose, fclosenotify);
+	LISTEN(&c->foreign_toplevel->events.request_fullscreen, &c->ffullscreen, ffullscreennotify);
+	LISTEN(&c->foreign_toplevel->events.destroy, &c->fdestroy, fdestroynotify);
+}
+
+void
+factivatenotify(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, factivate);
+	if (c->mon == selmon) {
+		c->tags = c->mon->tagset[c->mon->seltags];
+	} else {
+		setmon(c, selmon, 0);
+	}
+	focusclient(c, 1);
+	arrange(c->mon);
+}
+
+void
+fclosenotify(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, fclose);
+	client_send_close(c);
+}
+
+void
+ffullscreennotify(struct wl_listener *listener, void *data) {
+	Client *c = wl_container_of(listener, c, ffullscreen);
+	struct wlr_foreign_toplevel_handle_v1_fullscreen_event *event = data;
+	setfullscreen(c, event->fullscreen);
+}
+
+void
+fdestroynotify(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, fdestroy);
+	wl_list_remove(&c->factivate.link);
+	wl_list_remove(&c->fclose.link);
+	wl_list_remove(&c->ffullscreen.link);
+	wl_list_remove(&c->fdestroy.link);
+}
+
 #ifdef XWAYLAND
 void
 activatex11(struct wl_listener *listener, void *data)
